<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Editor de PDF Local</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f2f2f2;
    margin: 20px;
    text-align: center;
  }
  #pdf-container {
    position: relative;
    display: inline-block;
    border: 1px solid #ccc;
    background: white;
  }
  canvas {
    touch-action: none;
  }
  #controles {
    margin-top: 10px;
  }
</style>
</head>
<body>

<h2>Editor de PDF Local</h2>

<input type="file" id="file-input" accept="application/pdf">
<div id="controles">
  <label>Espessura: <input type="range" id="espessura" min="0.5" max="5" step="0.5" value="1"></label>
  <button id="modoRabisco">‚úèÔ∏è Rabisco</button>
  <button id="modoTexto">üî§ Texto</button>
  <button id="salvar">üíæ Salvar PDF</button>
</div>

<div id="pdf-container"></div>

<script type="module">
import { PDFDocument, rgb } from "https://cdn.skypack.dev/pdf-lib";
import * as pdfjsLib from "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/+esm";

pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.worker.min.js";

let pdfBytesOriginal = null;
let page, scale = 1.3, canvas, ctx;
let desenhando = false, modo = "rabisco";
let pontos = [], textos = [];

const container = document.getElementById("pdf-container");
const input = document.getElementById("file-input");
const espessuraInput = document.getElementById("espessura");

input.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  pdfBytesOriginal = await file.arrayBuffer();

  const pdf = await pdfjsLib.getDocument({ data: pdfBytesOriginal }).promise;
  page = await pdf.getPage(1);

  const viewport = page.getViewport({ scale });
  container.innerHTML = "";
  canvas = document.createElement("canvas");
  canvas.width = viewport.width;
  canvas.height = viewport.height;
  container.appendChild(canvas);

  ctx = canvas.getContext("2d");
  await page.render({ canvasContext: ctx, viewport }).promise;
  habilitarInteracao();
});

function habilitarInteracao() {
  // MOUSE
  canvas.addEventListener("mousedown", iniciarDesenho);
  canvas.addEventListener("mousemove", desenhar);
  window.addEventListener("mouseup", pararDesenho);

  // TOQUE
  canvas.addEventListener("touchstart", (e) => iniciarDesenho(e.touches[0]));
  canvas.addEventListener("touchmove", (e) => desenhar(e.touches[0]));
  canvas.addEventListener("touchend", pararDesenho);
}

function getCoordenadas(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function iniciarDesenho(e) {
  if (modo === "rabisco") {
    desenhando = true;
    pontos.push([]);
    const { x, y } = getCoordenadas(e);
    pontos[pontos.length - 1].push({ x, y });
  } else if (modo === "texto") {
    const { x, y } = getCoordenadas(e);
    const ponto = document.createElement("div");
    ponto.style.position = "absolute";
    ponto.style.width = "8px";
    ponto.style.height = "8px";
    ponto.style.background = "red";
    ponto.style.borderRadius = "50%";
    ponto.style.left = `${x - 4}px`;
    ponto.style.top = `${y - 4}px`;
    container.appendChild(ponto);

    const texto = prompt("Digite o texto:");
    if (texto) textos.push({ texto, x, y });
    container.removeChild(ponto);

    renderPDF();
  }
}

function desenhar(e) {
  if (!desenhando || modo !== "rabisco") return;
  const { x, y } = getCoordenadas(e);
  const trilha = pontos[pontos.length - 1];
  trilha.push({ x, y });

  ctx.lineWidth = espessuraInput.value;
  ctx.lineCap = "round";
  ctx.strokeStyle = "black";
  ctx.beginPath();
  const anterior = trilha[trilha.length - 2];
  if (anterior) {
    ctx.moveTo(anterior.x, anterior.y);
    ctx.lineTo(x, y);
    ctx.stroke();
  }
}

function pararDesenho() {
  desenhando = false;
}

document.getElementById("modoRabisco").onclick = () => (modo = "rabisco");
document.getElementById("modoTexto").onclick = () => (modo = "texto");

async function renderPDF() {
  const pdf = await pdfjsLib.getDocument({ data: pdfBytesOriginal }).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({ scale });
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  await page.render({ canvasContext: ctx, viewport }).promise;

  ctx.lineWidth = espessuraInput.value;
  ctx.strokeStyle = "black";
  ctx.lineCap = "round";
  pontos.forEach(trilha => {
    ctx.beginPath();
    for (let i = 1; i < trilha.length; i++) {
      ctx.moveTo(trilha[i - 1].x, trilha[i - 1].y);
      ctx.lineTo(trilha[i].x, trilha[i].y);
    }
    ctx.stroke();
  });

  ctx.fillStyle = "black";
  ctx.font = "14px Arial";
  textos.forEach(t => ctx.fillText(t.texto, t.x, t.y));
}

document.getElementById("salvar").addEventListener("click", async () => {
  const pdfDoc = await PDFDocument.load(pdfBytesOriginal);
  const page = pdfDoc.getPages()[0];
  const { height } = page.getSize();

  pontos.forEach(trilha => {
    for (let i = 1; i < trilha.length; i++) {
      page.drawLine({
        start: { x: trilha[i - 1].x, y: height - trilha[i - 1].y },
        end: { x: trilha[i].x, y: height - trilha[i].y },
        thickness: parseFloat(espessuraInput.value),
        color: rgb(0, 0, 0)
      });
    }
  });

  textos.forEach(t => {
    page.drawText(t.texto, {
      x: t.x,
      y: height - t.y,
      size: 12,
      color: rgb(0, 0, 0)
    });
  });

  const pdfEditado = await pdfDoc.save();
  const blob = new Blob([pdfEditado], { type: "application/pdf" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "editado.pdf";
  link.click();
});
</script>

</body>
</html>
